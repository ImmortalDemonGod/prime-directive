{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Project Repository and Dependencies",
        "description": "Set up the prime-directive repository structure and install all required dependencies using uv for Python 3.11+",
        "details": "Create repository structure exactly as specified: bin/, system/, core/, data/. Use `uv init prime-directive` then `uv add typer[all]>=0.12.0 sqlmodel>=0.0.22 watchdog>=5.0.2 rich>=13.9.0 requests>=2.32.0 pyyaml>=6.0.2`. Create pyproject.toml with [project.scripts]: pd=prime_directive.bin.pd:cli, pd-daemon=prime_directive.bin.pd_daemon:main. Initialize git and create .gitignore for data/ and __pycache__.",
        "testStrategy": "Run `uv sync` and verify `pd --help` shows Typer CLI. Check `tree prime-directive/` matches exact structure. `pytest --version` works.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Registry Configuration Parser",
        "description": "Create system/registry.yaml parser that loads repository mappings with extended schema including editor_cmd",
        "details": "In core/registry.py: Load system/registry.yaml with schema {system: {editor_cmd: str='windsurf', ai_model: str='qwen2.5-coder', db_path: str}, repos: [{id: str, path: str, priority: int}]}. Use pydantic v2.9+ BaseModel for validation. Default editor_cmd='windsurf' (verified as VSCode fork with identical CLI: windsurf <path> works per 2025 comparisons[1][2]). Validate all repo paths exist.",
        "testStrategy": "Create test registry.yaml with 2 repos. `pd list` outputs rich table with ID, path, priority. pytest tests/test_registry.py verifies parsing.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Setup SQLite Database Schema",
        "description": "Implement core/db.py with exact SQLModel schema for Repository and ContextSnapshot tables",
        "details": "Use SQLModel 0.0.22+: class Repository(SQLModel, table=True) with id:str=Field(primary_key=True), path:str, priority:int, active_branch:str, last_snapshot_id:Optional[int]=Field(default=None). class ContextSnapshot(SQLModel, table=True) with id:int=Field(primary_key=True, index=True), repo_id:str, timestamp:datetime, git_status_summary:str, terminal_last_command:str, terminal_output_summary:str, ai_sitrep:str. Use SQLite URL: f'sqlite+aiosqlite:///{config.db_path}' with aiosqlite 0.21+. Create engine with create_engine(..., connect_args={'check_same_thread': False}).",
        "testStrategy": "pytest tests/test_db.py: Create DB, insert Repository, insert ContextSnapshot, query back and verify data integrity and timestamps.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Git State Detection",
        "description": "Create git_utils to capture branch, dirty status, and diff summary for any repository",
        "details": "In core/git_utils.py: def get_status(repo_path: str) -> dict: Use subprocess.run(['git', 'rev-parse', '--abbrev-ref', 'HEAD']) for branch, ['git', 'status', '--porcelain'] for dirty files, ['git', 'diff', '--stat'] for summary. Return {'branch': str, 'is_dirty': bool, 'uncommitted_files': list[str], 'diff_stat': str}. Handle non-git repos gracefully.",
        "testStrategy": "pytest tests/test_git.py: Create temp git repo, make changes, verify get_status() returns correct dirty state and branch.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Task Master Adapter",
        "description": "Create core/tasks.py to parse .taskmaster/tasks.json and extract active/in-progress tasks",
        "details": "def get_active_task(repo_path: str) -> Optional[dict]: Check for .taskmaster/tasks.json, load JSON, filter tasks where status=='in-progress', return highest priority or most recent. Schema matches user_json_schema exactly. Handle missing file gracefully (return None).",
        "testStrategy": "Create mock tasks.json with in-progress tasks, verify get_active_task() returns correct highest priority task.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Build AI Scribe Engine with Ollama Integration",
        "description": "Implement core/scribe.py for generating SITREP summaries using Ollama Qwen2.5-Coder",
        "details": "Use requests 2.32+ to POST to http://localhost:11434/api/generate. System prompt: 'You are a concise engineering assistant. Given git state, terminal logs, and active task, generate a 2-3 sentence SITREP with IMMEDIATE NEXT STEP in 50 words max.' Include active task from tasks.py, git_status_summary, terminal logs. Model: qwen2.5-coder (per spec). Timeout 5s. def generate_sitrep(repo_id: str, git_state: str, terminal_logs: str, active_task: Optional[dict]) -> str.",
        "testStrategy": "Manual: ollama serve, feed mock error traceback, verify coherent summary <50 words in <2s. Check prime.db ai_sitrep field.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Terminal State Capture",
        "description": "Capture last 50 lines of active terminal and last command for freeze operation",
        "details": "In core/terminal.py: def capture_terminal_state() -> tuple[str, str]: Use subprocess.run(['tmux', 'capture-pane', '-p', '-S', '-50']) for last 50 lines, ['tmux', 'show-buffer'] or history parsing for last command. Fallback to 'history | tail -n 1' if not in tmux. Return (last_command: str, output_summary: str).",
        "testStrategy": "Manual: Run echo 'test error', pd freeze, verify terminal_output_summary contains 'test error' in DB.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Tmux Session Management",
        "description": "Create core/tmux.py for idempotent session create/attach with pd-<repo_id> naming",
        "details": "def ensure_session(repo_id: str, repo_path: str): session_name=f'pd-{repo_id}'. Check tmux ls | grep session_name, if exists: tmux attach -t session_name. Else: tmux new-session -d -s session_name 'cd {repo_path} && uv shell'. def detach_current(): tmux detach-client. Use subprocess.run(['tmux', ...], capture_output=True).",
        "testStrategy": "Manual Test 3.1: pd switch test-project (creates), detach, pd switch test-project (attaches existing, no duplication).",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Windsurf Editor Control",
        "description": "Launch Windsurf editor with correct flags using configurable editor_cmd",
        "details": "In core/windsurf.py: def launch_editor(repo_path: str, editor_cmd: str): subprocess.Popen([editor_cmd, '-n', repo_path]) # -n = new window/instance (VSCode/Windsurf compatible per[1][3]). Windsurf confirmed as VSCode fork with identical CLI flags[1][2][6]. Reuse existing windows via Windsurf Hot Exit.",
        "testStrategy": "Manual Test 3.2: pd switch black-box opens Windsurf at correct path (new window or reuse existing).",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Core CLI Commands (list, status, doctor)",
        "description": "Build bin/pd CLI with Typer: pd list, pd status (rich table), pd doctor (health checks)",
        "details": "Typer app: @app.command() def list(): rich table of repos from registry. def status(): Enhanced table with git_state=git_utils.get_status(), last_snapshot from DB, emoji status (ðŸŸ¢ðŸ”´ðŸŸ¡). def doctor(): Check shutil.which('tmux'), which(editor_cmd), requests.get('http://localhost:11434/api/tags') contains 'qwen2.5-coder', all registry paths exist.",
        "testStrategy": "pd list shows registry table. pd doctor passes all checks when dependencies installed.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4,
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Freeze Operation (Snapshot Current State)",
        "description": "Create pd freeze: capture git/terminal/task state, generate AI SITREP, save to DB",
        "details": "In bin/pd: @app.command() def freeze(repo_id: str): current_path=get_cwd_repo(), git_state=git_utils.get_status(), terminal=terminal.capture(), task=tasks.get_active_task(), sitrep=scribe.generate_sitrep(...), db.save_snapshot(repo_id, git_state..., sitrep). Timestamp=datetime.utcnow().",
        "testStrategy": "Manual Test 2.3: In dirty repo run pd freeze, verify new DB row with AI summary.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5,
          6,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Switch/Warp Protocol (Full Context Switch)",
        "description": "Core pd switch <repo>: freeze current -> thaw target with SITREP display",
        "details": "def switch(repo_id: str): if current_repo(): freeze(current_repo()). target=tmux.ensure_session(repo_id, path), windsurf.launch_editor(path, editor_cmd). Print rich SITREP banner: last_snapshot=DB.get_latest(repo_id), f'>>> LAST ACTION: {snapshot.ai_sitrep}\\n>>> GIT: {git_status}\\n>>> NEXT: {next_step}'.",
        "testStrategy": "Full E2E: pd switch repo1 (freeze), pd switch repo2 (thaw+display SITREP), verify tmux attaches correctly.",
        "priority": "high",
        "dependencies": [
          8,
          9,
          10,
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Shell Integration (zsh wrapper)",
        "description": "Create system/shell_integration.zsh with cd/tmux hijacking for seamless pd switch",
        "details": "In ~/.zshrc: source path/to/shell_integration.zsh. function cd() { if [[ $1 == pd-* ]]; then pd switch ${1#pd-}; else builtin cd $@; fi }. Alias pd=~/path/to/bin/pd. Auto-attach tmux on pd switch.",
        "testStrategy": "Manual Test 3.3: Source integration, type 'cd pd-rna-predict', verify enters tmux session.",
        "priority": "medium",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Background Daemon Service",
        "description": "Create bin/pd-daemon for Watchdog monitoring and auto-freeze on inactivity",
        "details": "Use watchdog 5.0+: monitor registry repo paths, on file changes or inactivity (>30min) trigger freeze(). Run as `pd-daemon` service with systemd or nohup. Log to data/logs/.",
        "testStrategy": "Run pd-daemon, modify file in watched repo, verify auto-freeze creates DB snapshot.",
        "priority": "low",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Comprehensive Integration Testing and Amnesia Test",
        "description": "Run full verification suite including Amnesia Test and Crash Test",
        "details": "Execute all manual tests 1.1-3.3. Amnesia Test: Work on repo1 30min, switch away 24h, pd switch repo1, commit code <5min. Crash Test: kill terminal, pd switch, verify exact state restored.",
        "testStrategy": "Pass all 6 Green Lights + Amnesia/Crash tests. Tune scribe prompt if SITREP insufficient.",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "in-progress",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-12-15T00:38:44.382Z",
      "updated": "2025-12-15T01:52:57.342Z",
      "description": "Tasks for master context"
    }
  }
}