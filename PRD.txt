Understood. A dedicated repo for the orchestration layer is cleaner. And switching from VS Code to **Windsurf** is critical context because Windsurf has different CLI behaviors and workspace handling mechanisms (though it forks VS Code, we must verify the command flags).

Here is the revised, canonical specification for **Project: Prime Directive**.

---

# Prime Directive v1.0: Meta-Orchestration Specification

**Document ID:** `PRIME-DIRECTIVE-ARCH-V1.0`
**Date:** 2025-12-08
**Status:** Approved for Implementation
**Role:** The Command Center / The Architect's Console
**Repository Name:** `prime-directive`

---

## 1. Executive Summary

**Prime Directive** is the central nervous system for the user's multi-project ecosystem. It is a standalone repository designed to solve the **"Polymath's Trap"**â€”the cognitive and operational friction of managing multiple high-complexity domains (`black-box`, `rna-predict`, `cultivation-os`).

**Core Mandate:**
1.  **Federation:** Aggregates task data from distributed repositories without centralization.
2.  **Persistence:** Maintains the runtime state (`tmux`) and editor context (`windsurf`) of inactive projects.
3.  **Synthesis:** Uses AI to generate "Situation Reports" (SITREPs) during context switches.

**The Interface:** A global CLI tool (`pd`) installed on the host machine.

---

## 2. Architecture: The Client-Daemon Model

### 2.1 The Repository Structure (`prime-directive`)

```text
prime-directive/
â”œâ”€â”€ pyproject.toml              # Dependencies (Typer, SQLModel, Watchdog, Ollama)
â”œâ”€â”€ uv.lock
â”‚
â”œâ”€â”€ bin/                        # Entrypoints
â”‚   â”œâ”€â”€ pd                      # The CLI Client
â”‚   â””â”€â”€ pd-daemon               # The Background Service
â”‚
â”œâ”€â”€ system/                     # Configuration
â”‚   â”œâ”€â”€ registry.yaml           # The "Map of the Empire" (Repo paths & priorities)
â”‚   â””â”€â”€ shell_integration.zsh   # Zsh functions for cd/tmux hijacking
â”‚
â”œâ”€â”€ core/                       # Logic Layer
â”‚   â”œâ”€â”€ db.py                   # SQLite Schema & connection
â”‚   â”œâ”€â”€ scribe.py               # AI Context Engine (Ollama wrapper)
â”‚   â”œâ”€â”€ windsurf.py             # Editor Control Logic
â”‚   â””â”€â”€ tmux.py                 # Session Management Logic
â”‚
â””â”€â”€ data/                       # State (Gitignored)
    â”œâ”€â”€ prime.db                # The Index
    â””â”€â”€ logs/
```

### 2.2 The Tech Stack
*   **Runtime:** Python 3.11+ (`uv`).
*   **Database:** **SQLite**. Simple, fast, local.
*   **Editor Target:** **Windsurf**.
    *   *Constraint:* Must verify if `windsurf` CLI supports `.code-workspace` or if it requires directory paths. (Assumption: It supports `windsurf <path>` similar to `code`).
*   **Session Manager:** **Tmux**.
*   **AI Engine:** **Ollama** (Local Qwen-2.5-Coder). Zero-latency, free, private context analysis.

---

## 3. The Data Schema

We need a rigorous schema to map the "Empire."

```python
class Repository(SQLModel, table=True):
    id: str = Field(primary_key=True)       # "rna-predict"
    path: str                               # "/home/miguel/dev/rna-predict"
    priority: int                           # 1-10
    active_branch: str
    last_snapshot_id: Optional[int]

class ContextSnapshot(SQLModel, table=True):
    id: int = Field(primary_key=True)
    repo_id: str
    timestamp: datetime
    # The "Auto-Scribe" Data
    git_status_summary: str                 # "3 modified files, 1 uncommitted"
    terminal_last_command: str              # "pytest tests/test_model.py"
    terminal_output_summary: str            # "Tests failed: ShapeMismatch"
    ai_sitrep: str                          # "You were debugging tensor shapes."
```

---

## 4. The "Warp" Protocol (Context Switching)

This is the core feature. The command `pd switch <repo>` replaces manual `cd`.

### A. The "Freeze" Sequence (Leaving Project A)
1.  **Trigger:** User types `pd switch rna-predict` while inside `black-box`.
2.  **Scribe Activation:**
    *   The Daemon captures the last 50 lines of the `black-box` tmux pane.
    *   It runs `git diff --stat`.
    *   It sends this to Ollama: *"Summarize my state."*
3.  **Persist:** Saves the AI summary to `prime.db`.
4.  **Detach:** Detaches the `black-box` tmux client (keeping the server running).

### B. The "Thaw" Sequence (Entering Project B)
1.  **Environment:**
    *   Checks for existing tmux session `pd-rna-predict`.
    *   If missing: Creates it, `cd` to path, activates `uv` venv.
    *   If exists: Attaches client.
2.  **Editor:**
    *   Executes `windsurf -n <repo_path>`. (`-n` forces new window/instance if needed, or reuses existing).
    *   *Crucial:* We rely on Windsurf's internal "Hot Exit" / "Workspace Restore" feature to handle open tabs. We just point it to the root folder.
3.  **Briefing:**
    *   Prints the **SITREP** to the terminal:
        ```text
        [ PRIME DIRECTIVE ] :: ENTERING RNA-PREDICT
        -------------------------------------------
        >>> LAST ACTION (14h ago): Debugging Gradient Explosion.
        >>> GIT STATE: Feature branch 'fix-torsion' (Dirty).
        >>> IMMEDIATE TASK: Check normalization layers.
        ```

---

## 5. The "Overseer" Dashboard

The CLI needs a HUD mode.

**Command:** `pd status`
*   **Output:** A rich table (via `rich` library).

| Project | Priority | Active Branch | Task Status | Last Touch |
| :--- | :--- | :--- | :--- | :--- |
| **black-box** | ðŸ”¥ CRITICAL | `main` | ðŸŸ¢ 2 In-Progress | 2m ago |
| **rna-predict** | ðŸ”¬ RESEARCH | `exp/diffusion` | ðŸ”´ Build Fail | 14h ago |
| **cultivation-os** | âš™ï¸ KERNEL | `dev` | ðŸŸ¡ 1 Pending | 1d ago |

---

## 6. Implementation Plan

We execute this in **3 Days**.

#### **Day 1: The Registry & CLI Skeleton**
1.  Initialize `prime-directive` repo.
2.  Create `system/registry.yaml` and list your 3-4 active repos.
3.  Build `pd` CLI (Typer). Implement `pd list` that reads the registry.
4.  **Verification:** `pd list` prints your projects.

#### **Day 2: The Scribe & Database**
1.  Implement `core/db.py` and `core/scribe.py`.
2.  Wire up **Ollama**. Test a prompt: "Summarize this git diff."
3.  Implement the "Freeze" logic (Capture state -> DB).
4.  **Verification:** Run `pd snapshot`. Check if DB has a new row with an AI summary.

#### **Day 3: The Switcher (Tmux + Windsurf)**
1.  Write the `shell_integration.zsh` wrapper.
2.  Implement `core/tmux.py` to handle session creation/attachment.
3.  Implement the Windsurf launch command.
4.  **Verification:** `pd switch black-box` puts you in a persistent tmux session and opens the IDE.

---

### 7. Strategic Implication

**Prime Directive** is the "Manager" you cannot hire.
*   **Cultivation OS** optimizes the **Operator** (You).
*   **Prime Directive** optimizes the **Work** (The Code).

By decoupling this into its own repo, you ensure that your management tooling is robust, versioned, and independent of the projects it manages. This is the correct architecture for scaling a one-man empire.


The core user story is **"Zero-Friction Re-Entry."**

You know the system is working when you can stop working on a complex project (like `rna-predict`) on Friday night, spend the weekend on `black-box`, and then return to `rna-predict` on Monday morning and **know exactly what to type next within 10 seconds.**

---

### The User Story: "The Monday Morning Warp"

**The Scenario:**
It is Monday at 09:00. You have not touched `rna-predict` in 72 hours. Your brain cache has been flushed. You remember vaguely that you were "fixing something with gradients."

**Without Prime Directive:**
1.  You `cd` into the folder.
2.  You run `git status`. It's dirty. "What was I changing?"
3.  You open Windsurf. 10 tabs open. You stare at `model.py`. "Why is this line commented out?"
4.  You scroll up in your terminal to see the last error. The history is gone (or cluttered).
5.  **Result:** You spend 45 minutes reading code just to remember what the bug was.

**With Prime Directive:**

1.  **Action:** You type `pd switch rna-predict`.
2.  **Visual:** Your terminal clears. A banner appears.
3.  **The SITREP (Generated by AI on Friday):**
    ```text
    [ PRIME DIRECTIVE ] :: WARPING TO RNA-PREDICT
    ---------------------------------------------
    >>> SITUATION REPORT (Friday 22:45):
    You were implementing the 'SE(3) Equivariant Loss'.
    The unit test `test_rotation_invariance` failed with `AssertionError: 0.8 != 1.0`.
    You determined the issue is in the normalization layer in `equivariant.py`.

    >>> IMMEDIATE NEXT STEP:
    Open `equivariant.py` line 142 and remove the hardcoded epsilon.
    ```
4.  **The Environment:**
    *   Windsurf opens immediately with `equivariant.py` focused.
    *   Your terminal is *already attached* to the session from Friday. The error message `AssertionError: 0.8 != 1.0` is still visible on the screen. The server is still running.
5.  **The Result:** You type the fix immediately. **Time to code: 10 seconds.**

---

### The Pass/Fail Criteria

To verify if **Prime Directive** is actually working, apply this test:

1.  **The "Amnesia Test":** Can you switch to a project you haven't touched in a week and commit valid code within 5 minutes?
    *   **Yes:** Working.
    *   **No:** The SITREP wasn't detailed enough (Tune the AI Prompt).

2.  **The "Crash Test":** If you close your terminal window and reopen it, does `pd switch` put you back *exactly* where you were (same command history, same running processes)?
    *   **Yes:** Working (Tmux is holding state).
    *   **No:** Broken (Session management failed).

If the system passes the **Amnesia Test**, you have solved the Polymath's Trap.


You are right. To execute the **Verifier** role effectively during the build of **Prime Directive**, we need granular tests that validate each component *before* we attempt the full End-to-End "Monday Morning Warp."

We will use **Pytest** for the logic and **Manual Verification Steps** for the shell/tmux interactions (since automating tmux tests is brittle).

Here are the **Core Development Verification Tests** for the 3-day build.

---

### **Day 1: The Registry & CLI Skeleton**
*Goal: Can we find the projects and read their state?*

#### **Test 1.1: Registry Parsing (Automated)**
*   **Input:** A mock `registry.yaml` with 2 dummy repos.
*   **Action:** `pd list`
*   **Expected Output:** A JSON or Table listing the correct paths and priorities.
*   **Verifier:** `pytest tests/test_registry.py`

#### **Test 1.2: Git State Detection (Automated)**
*   **Setup:** Create a temporary git repo. Make a change but don't commit it.
*   **Action:** Run `core.git_utils.get_status(repo_path)`.
*   **Expected Output:** Returns a data object: `{ branch: "master", is_dirty: True, uncommitted_files: ["test.py"] }`.
*   **Verifier:** `pytest tests/test_git.py`

---

### **Day 2: The Scribe & Database**
*Goal: Can we capture state and persist it?*

#### **Test 2.1: The Snapshot Transaction (Automated)**
*   **Setup:** Initialize a fresh SQLite DB.
*   **Action:** Call `db.save_snapshot(repo="test-repo", git_state="...", logs="...")`.
*   **Verification:** Query the DB. Ensure the row exists with the correct timestamp.
*   **Verifier:** `pytest tests/test_db.py`

#### **Test 2.2: The AI Summarizer (Manual/Integration)**
*   **Setup:** Ensure Ollama is running (`ollama serve`).
*   **Action:** Run a script that feeds a raw string of "Python Error Traceback" to the `Scribe` class.
*   **Expected Output:** A concise English summary (e.g., "Python script failed due to IndexError").
*   **Verification:** Read the output. Is it coherent? Is it fast (< 2s)?
    *   *Failure Mode:* If it hallucinates or is slow, tune the System Prompt in `scribe.py`.

#### **Test 2.3: The Freeze Hook (Manual)**
*   **Setup:** Open a dummy project. Run `echo "Critical Failure"`.
*   **Action:** Run `pd freeze`.
*   **Verification:** Check `prime.db`. Does the latest snapshot contain the text "Critical Failure" in the logs field?
    *   *Why:* This proves we are successfully scraping the active terminal buffer.

---

### **Day 3: The Switcher (Tmux + Windsurf)**
*   **Goal:** Can we control the environment?*

#### **Test 3.1: Tmux Session Idempotency (Manual)**
*   **Action 1:** Run `pd switch test-project`. (Should create session `pd-test-project`).
*   **Action 2:** Detach. Run `pd switch test-project` *again*.
*   **Expected Result:** It attaches to the **existing** session. It does **not** create `pd-test-project-1`.
*   *Why:* Prevents session proliferation.

#### **Test 3.2: Windsurf Launch (Manual)**
*   **Action:** Run `pd switch black-box`.
*   **Expected Result:** Windsurf opens the `black-box` folder.
    *   *Crucial Check:* Does it open a *new* window or reuse an existing one? (Tune the CLI flags `-n` or `-r` to your preference).

#### **Test 3.3: The Shell Wrapper (Manual)**
*   **Action:** Type `pd switch rna-predict` in your main terminal.
*   **Expected Result:** The terminal prompt changes. You are now *inside* the tmux session.
*   **Failure Mode:** If the python script runs but you are still in your original shell, the `.zshrc` wrapper is broken.

---

### **Summary of the "Green Lights"**

| Component | Test Type | Success Metric |
| :--- | :--- | :--- |
| **Registry** | Unit | `pytest` passes 100%. |
| **Git Logic** | Unit | Correctly identifies "Dirty" repos. |
| **Database** | Unit | Snapshots persist across restarts. |
| **AI Scribe** | Integration | Summaries are < 50 words and accurate. |
| **Tmux** | Manual | Re-attaches to existing sessions 100% of time. |
| **Shell** | Manual | `pd switch` actually changes the terminal context. |

If you pass these 6 checks, the system is solid. You can then trust it with your actual workflow.


### Critical Gap Analysis: Prime Directive vs. AIV Workflow

**Subject:** Architectural Completeness Audit of `PRIME-DIRECTIVE-ARCH-V1.0`
**Context:** Transitioning to a meta-orchestrator (`prime-directive`) to manage multi-repo context switching.
**Goal:** Verify if any critical components are missing to achieve the "Monday Morning Warp" and satisfy the AIV verification steps.

---

### 1. Analysis of Missing Components

Based on the provided documents (`PRIME-DIRECTIVE-ARCH-V1.0` and the AIV Verification Plan), here are the critical gaps identified in the current specification relative to a "Full System Build."

#### **Gap A: The "Task Master" Interface Layer**
*   **Observation:** The specification focuses heavily on *Context* (Git + Terminal state) but lightly on *Tasks* (the actual work items).
*   **The Missing Piece:** The `prime-directive` repo lacks a defined interface to query the `tasks.json` files inside the target repos.
    *   *Why it matters:* The "SITREP" includes "IMMEDIATE TASK: Check normalization layers." To generate this, `pd` needs to read `rna-predict/.taskmaster/tasks.json`, find the active task, and feed it to the LLM.
    *   *Requirement:* A `core/taskmaster_adapter.py` module that parses the Task Master schema. Without this, the AI Scribe is blind to the structured plan.

#### **Gap B: The "LLM Configuration" Protocol**
*   **Observation:** The spec assumes `ollama` is running and `qwen2.5-coder` is installed.
*   **The Missing Piece:** A setup/check routine.
    *   *Why it matters:* If you run `pd switch` on a new machine (or after a reboot) and Ollama isn't running, the freeze/thaw cycle crashes or hangs.
    *   *Requirement:* A `system/health_check.py` or `bin/pd doctor` command that verifies:
        1.  Ollama is reachable (`http://localhost:11434`).
        2.  The target model is pulled.
        3.  Tmux is installed.
        4.  Windsurf binary is in PATH.

#### **Gap C: The "Multi-Device" Sync Strategy**
*   **Observation:** The `prime.db` (SQLite) is local.
*   **The Missing Piece:** If you switch from Desktop to Laptop, your "Context" is lost because the DB is on the Desktop.
*   **Mitigation:** The current spec handles *local* context switching well. *Syncing* context across devices is a P2 feature, but the architecture should acknowledge it (e.g., by placing `prime.db` in a synced folder like Dropbox/iCloud or using rsync). *Decision: Out of scope for V1 MVP, but worth noting.*

#### **Gap D: The "Windsurf" Specifics**
*   **Observation:** The spec assumes `windsurf -n <path>` works like VS Code.
*   **The Missing Piece:** Windsurf might use a different binary name (e.g., `windsurf-cli` or just `code` if it aliases).
    *   *Requirement:* A configuration field in `registry.yaml` for `editor_command`. Hardcoding `windsurf` is brittle.

---

### 2. Recommendations for "The Missing Document"

You need a **Technical Addendum** to cover the "Glue" between the high-level architecture and the low-level code. Specifically, the **Task Master Integration** and **System Resilience** layers.

I will generate this addendum now.

---

# Prime Directive v1.0: Technical Addendum (Gap Remediation)

**Document ID:** `PRIME-DIRECTIVE-ADDENDUM-V1.0`
**Date:** 2025-12-08
**Status:** Required for V1 Completion

## 1. The Task Master Adapter (`core/tasks.py`)

To fulfill the promise of the SITREP, `pd` must be able to read the *intent* of the user, not just their terminal history.

### **Functionality:**
*   **`get_active_task(repo_path: str) -> dict`**:
    1.  Locates `.taskmaster/tasks.json`.
    2.  Parses the JSON.
    3.  Filters for `status == "in-progress"`.
    4.  Returns the task with the highest priority/most recent modification.

### **Integration:**
*   **Input to Scribe:** The AI Prompt in `scribe.py` is updated:
    ```python
    prompt = f"""
    Context:
    - Active Task: {task['title']}
    - Task Details: {task['details']}
    - Git Diff: {git_summary}
    - Terminal Logs: {term_logs}
    
    Summarize progress and next steps.
    """
    ```

## 2. The Resilience Layer (`bin/pd doctor`)

Before "going live," the system must self-diagnose.

### **Command:** `pd doctor`
**Checks:**
1.  **Dependencies:** `shutil.which("tmux")`, `shutil.which("windsurf")` (or configured editor).
2.  **AI Engine:**
    *   `requests.get("http://localhost:11434/api/tags")` (Check Ollama).
    *   Verify `qwen2.5-coder` is in the model list.
    *   *Auto-Fix:* If model missing, prompt to run `ollama pull qwen2.5-coder`.
3.  **Registry:** Validate `registry.yaml` paths exist.

## 3. Configuration Schema Update (`registry.yaml`)

We add `editor_cmd` to allow flexibility (VS Code vs Windsurf vs Cursor).

```yaml
system:
  editor_cmd: "windsurf" # or "code", "cursor"
  ai_model: "qwen2.5-coder"
  db_path: "~/.cultivation/prime.db" # Allows syncing if moved to Dropbox

repos:
  - id: black-box
    path: ...
```

## 4. Modified Implementation Plan

**Day 1 Additions:**
*   Add `editor_cmd` to config schema.
*   Implement `pd doctor` (It's easier to debug setup issues early).

**Day 2 Additions:**
*   Implement `core/tasks.py` (The JSON parser).
*   Update `scribe.py` to ingest the Task JSON.

This closes the loop between **Execution** (The Shell) and **Intent** (Task Master), ensuring the AI summary is grounded in the actual project goals.